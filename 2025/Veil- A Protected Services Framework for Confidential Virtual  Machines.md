1. VMPL（Virtual Machine Privilege Level）的硬件级隔离机制
VMPL的本质：
AMD SEV-SNP引入的VMPL是一种硬件支持的多级特权控制机制，允许在单个虚拟机（VM）内部划分多个特权层级（VMPL-0到VMPL-3）。每个层级对应不同的内存访问权限，形成类似传统操作系统中“用户态-内核态”的隔离，但粒度更细且由硬件直接控制。

权限控制细节：

VMPL-0（最高特权）：
唯一可执行RMPADJUST指令的层级，该指令用于修改Reverse Map Table (RMT)，控制物理页的访问权限（读/写/执行）。
可访问所有内存区域（包括其他VMPL域的内存）。
VMPL-1/2：
受限权限层级，仅能访问被VMPL-0显式授权的内存。
用于运行需要部分特权的服务（如日志守护进程）。
VMPL-3（最低特权）：
操作系统内核运行于此层级，无法修改内存权限或访问高特权域内存。
所有内存访问需通过VMPL-0的授权，确保内核被攻破后无法篡改安全服务。
硬件协同机制：

与x86 CPL（Current Privilege Level）的交互：
VMPL与x86原有的CPL（0-3级）形成二维权限模型。例如：
Dom_Mon（安全监视器域）：VMPL-0 + CPL-0，拥有最高权限。
Dom_Enc（飞地用户域）：VMPL-2 + CPL-3，仅能执行飞地代码。
这种组合使得即使攻击者在内核态（CPL-0）也无法突破VMPL的隔离限制。
2. 特权分层：VeilMon与内核的权限切割
VeilMon的职责：

内存权限仲裁者：
通过RMPADJUST指令动态分配物理页到不同VMPL域。例如：
将内核代码页设为VMPL-3可读/执行但不可写，防止代码篡改。
将飞地内存设为VMPL-2独占，阻止内核访问。
域间通信代理：
处理来自低特权域（如内核）的请求（如内存分配、飞地创建），验证合法性后执行高特权操作。
内核的限制：

权限剥夺：
内核运行在VMPL-3，失去直接操作硬件资源的能力（如修改页表、访问I/O端口）。
关键操作委托：
VCPU创建：内核调用ioctl(KVM_CREATE_VCPU)时，请求被重定向到VeilMon，由后者在VMPL-0创建VCPU。
内存验证：内核的PVALIDATE指令（用于确认内存加密状态）需通过VeilMon代理执行，防止恶意页面映射。
3. 动态VCPU复制的实现与优化
复制流程：

物理CPU初始化：
每个物理CPU对应多个VCPU实例，分别绑定到不同VMPL域（如VMPL-0用于VeilMon，VMPL-3用于内核）。
各VCPU共享相同的虚拟地址空间，但拥有独立的VMSA（Virtual Machine Save Area）保存寄存器状态。
域切换触发：
当内核需要调用安全服务（如记录日志）时，通过VMGEXIT指令退出到Hypervisor。
Hypervisor根据请求类型选择目标VMPL域，加载对应VCPU的VMSA，完成上下文切换。
通信通道：
IDCB（Inter-Domain Communication Block）：
预分配的共享内存区域，用于传递请求参数和返回结果。例如，内核将日志内容写入IDCB，触发切换到VeilMon域处理。
异步通知：通过虚拟中断（如#VC异常）通知目标域处理请求，避免轮询开销。
性能优化技术：

VMSA缓存：
复用相同VMPL域的VMSA状态，减少切换时的状态保存开销。
批处理请求：
将多个请求合并到一次域切换（如批量日志条目），降低切换频率。
共享内存锁定：
将IDCB内存标记为VMPL-0和VMPL-3均可访问，避免每次切换时重新配置权限。
